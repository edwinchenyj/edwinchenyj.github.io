---
title:  "Simple speed up for LDLT solver"
author: Ed
last_modified_at: 2023-02-15
categories:
        - Scientific Computing
tags:
        - Numercial Linear Algebra
toc: true
toc_sticky: true
excerpt: "Combining LDLT decomposition with forward substitution can reduce the number of for-loops from 3 to 2"
---

I came across with a piece of code for speeding up the LDLT solver for real-time hair simulation. One of the optimizations in this algorithm is combining the forward substitution with the LDLT decomposition. This trick is clever when each you only solve the system once for every pair of lefthand side and righthand side.
I shared some c++ code of this modification [here](https://github.com/edwinchenyj/scientific-computing-notes/tree/main/direct_solver)

### Regular LDLT

In a regular LDLT solver, there are 3 main loops:

1. LDLT decomposition
2. Forward Substitution
3. Backward Substitution

Once 1. is done, it can be reused for other righthand side, so only 2. and 3. need to be performed.

```cpp
vector<double> ldlt(vector<vector<double>> A, vector<double> b) {
    int n = A.size();
    vector<double> x(n, 0.0);
    vector<vector<double>> L(n, vector<double>(n, 0.0));
    vector<double> D(n, 0.0);
    vector<double> y(n, 0.0);

    // LDL decomposition
    for (int i = 0; i < n; i++) {
        double sum = 0.0;
        for (int k = 0; k < i; k++) {
            sum += L[i][k] * D[k] * L[i][k];
        }
        D[i] = A[i][i] - sum;
        L[i][i] = 1.0;


        for (int j = i + 1; j < n; j++) {
            double sum = 0.0;
            for (int k = 0; k < i; k++) {
                sum += L[j][k] * D[k] * L[i][k];
            }
            L[j][i] = (A[j][i] - sum) / D[i];
            L[i][j] = 0.0;
        }
    }

    // forward substitution
    for (int i = 0; i < n; i++) {
        double sum = 0.0;
        for (int k = 0; k < i; k++) {
            sum += L[i][k] * y[k];
        }
        y[i] = (b[i] - sum) / L[i][i];
    }

    // backward substitution
    for (int i = n - 1; i >= 0; i--) {
        double sum = 0.0;
        for (int k = i + 1; k < n; k++) {
            sum += L[k][i] * x[k];
        }
        x[i] = (y[i] - sum) / L[i][i];
    }

    return x;
}
```

### Modified LDLT solver

The main observation here is that, in the loop for forward substitution, the variables `L[i][k]` and `L[i][i]` are already computed in the corresponding loop in the LDLT decomposition, before the computation of `L[i][j]` and `L[j][i]` (the second inner loop above). So we can merge the first 2 for-loops.

```cpp
vector<double> modified_ldlt(vector<vector<double>> A, vector<double> b) {
    int n = A.size();
    vector<double> x(n, 0.0);
    vector<vector<double>> L(n, vector<double>(n, 0.0));
    vector<double> D(n, 0.0);
    vector<double> y(n, 0.0);

    // LDL decomposition
    for (int i = 0; i < n; i++) {
        double sum = 0.0;
        for (int k = 0; k < i; k++) {
            sum += L[i][k] * D[k] * L[i][k];
        }
        D[i] = A[i][i] - sum;
        L[i][i] = 1.0;

        // forward substitution
        sum = 0.0;
        for (int k = 0; k < i; k++) {
            sum += L[i][k] * y[k];
        }
        y[i] = (b[i] - sum) / L[i][i];

        // compute L
        for (int j = i + 1; j < n; j++) {
            double sum = 0.0;
            for (int k = 0; k < i; k++) {
                sum += L[j][k] * D[k] * L[i][k];
            }
            L[j][i] = (A[j][i] - sum) / D[i];
            L[i][j] = 0.0;
        }
    }

    // backward substitution
    for (int i = n - 1; i >= 0; i--) {
        double sum = 0.0;
        for (int k = i + 1; k < n; k++) {
            sum += L[k][i] * x[k];
        }
        x[i] = (y[i] - sum) / L[i][i];
    }

    return x;
}
```

Although the overall time complexity remains the same, $O(n^2)$, this type of performance improvement can be important in realtime applications.